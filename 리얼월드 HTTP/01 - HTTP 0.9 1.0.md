# HTTP/0.9
```text
HTTP/0.9는 매우 단순한 프로토콜이다.
텍스트 정보가 적힌 페이지 경로를 서버에 지정해서 해당 페이지를 가져오기마 하는 프로토콜.

[curl 실행 예]
$ curl --http1.0 http://localhost:8080/greeting
<html><body>hello</body></html>

0.9의 기본 기능은 이것 뿐이다.
웹 사이트의 페이지를 서버에 요청하고, 그 응답으로 웹 사이트의 내용을 받아온다
```

<br>
<hr>

## '폼'과 '검색 기능'
```text
HTML 문장 내에서 <isindex> 태그를 사용하면 검색할 수 있었다.

검색을 하면 주소 끝에 ? 기호와 단어를 붙여 검색 요청을 보낸다.
http://example.com/?search+word
```

<br>
<hr>

## HTTP/0.9에서 1.0으로의 여정
```
HTTP/0.9로는 할 수 없는 일이 많다.

- 하나의 문서를 전송하는 기능밖에 없다.
- 통신되는 모든 내용은 HTML 문서로 가정했으므로, 다운로드할 컨텐츠 형식을 서버가 전달할 수단이 없다.
- 클라이언트 쪽에서 검색 이외의 요청을 보낼 수 없다.
- 새로운 문장을 전송하거나 갱신, 삭제 할 수 없다.
- 요청이 올바른지 혹은 서버가 올바르게 응답했는지 확인할 수 없다.



1.0으로 추가된 기능은 다음과 같다.

[요청]
- 요청 시 메서드가 추가됐다 (GET)
- 요청 시 HTTP 버전이 추가됐다 (HTTP/1.0)
- 헤더가 추가됐다 (Host, User-Agent, Accept)

[응답]
- 응답 선두에 HTTP 버전과 3행의 스테이터스 코드가 포함됐다.
- 요청과 같은 형식의 헤더가 포함됐다.
```

<br>
<hr>

## 헤더
```
헤더는 서버와 클라이언트 사이에 필요한 추가 정보, 지시나 명령, 당부를 쓰는 장소이다.

[클라이언트 to 서버]
- User-Agent: 클라이언트가 자신의 애플리케이션 이름을 넣는 곳. 서버는 이 곳의 이름을 보고 응답을 전환하기도 한다.
피처폰이나 스마트폰, 브라우저의 종류나 버전을 구분할 수 있다.
- Referer: 서버에서 참고하는 추가 정보. 클라이언트가 요청을 보내 때 보고 있던 페이지 URL을 보낸다.
- Authorization: 특별한 클라이언트에만 통신을 허가할 때 인증 정보를 서버에게 전달한다.


[서버 to 클라이언트]
- Content-Type: 파일 종류를 지정. 여기에는 MIME 타입이라는 식별자를 기술한다.
MIME 타입은 전자메일을 위해 만들어진 식별자다
- Content-Length: 바디 크기. 압축이 이루어지는 경우 압축 후의 크기가 들어간다.
- Content-Encofing: 압축이 이루어진 경우 압축 형식을 설명한다.
- Date: 문서 날짜
```

### 헤더의 전송
```
curl 커맨드로 헤더를 보낸다면
$ curl --http1.0 -H "X-Test: Hello" http://localhost:8080

수신하는 쪽에선 다음과 같이 표시된다
GET / HTTP/1.0
Host: localhost:8080
Connection: close
Accept: */*
User-Agent: curl/7.48.0
X-Test: Hello
```

### MIME 타입
```
MIME 타입은 파일의 종류를 구분하는 문자열

일반적으로 보급된 웹사이트는 HTML 파일을 바탕으로 사진이나 음악을 붙인 것이 대부분이다.
브라우저는 OS와 별개로 파일 종류별로 어떤 동작을 할 지 관리한다.
이떄 파일 종류를 나타내는 식별자가 MIME 타입.
```

### Content-Type과 보안
```
브라우저 세계에서는 파일 종류를 특정할 때 Content-Type 헤더에서 지정된 MIME 타입을 사용한다.

인터넷 익스플로러는 인터넷 옵션에 따라 MIME 타입이 아닌 내용을 보고 파일 형식을 추측하려고 한다 (Content Sniffing).
원래 텍스트로만 표시돼야 하는 text/plain 파일인데도 HTML과 자바스크립트가 적혀 있으면 브라우저가 파일을 실행해버리는 일도 있다.

서버에서 다음과 같이 헤더를 전송해 브라우저가 추측하지 않도록 하는게 현재 주류의 방법
X-Content-Type-Options: nosniff
```

<br>
<hr>

## HTTP의 조상 (뉴스그룹)
```
기사를 읽거나 투고하는 플랫폼이 있었다.

뉴스그룹은 분산 아키텍처로 되어있다.

사용자는 서버에 구독하는 최신 기사를 요청하고 기사가 있으면 가져온다.
웹처럼 모든 사용자가 한곳의 서버에 접속하러 가는것이 아니라, 복수의 서버가 마스터/슬레이브 구조로
연결되어 있어, 슬레이브 서버도 클라이언트처럼 마스터 서버에 접속하고, 정보를 가져와 로컬에 저장한다.

이 클라이언트 서버 간 통신과 마스터 서버와 슬레이브 서버 간 통신에 사용된 것이 NNPT(Network News Transfer Protocol) 이다.

HTTP는 뉴스그룹으로부터 메서드와 스테이터스 코드라는 두 가지 기능을 도입했다.
```

### 메서드
```
- GET: 서버에 헤더와 컨텐츠 요청
- HEAD: 서버에 헤더만 요청
- POST: 새로운 문서 투고
- PUT: 이미 존재하는 URL의 문서를 갱신한다.
- DELETE: 지정된 URL의 문서를 삭제한다.


curl 커맨드로 메서드를 전송할 때는 --request= 메서드 혹은 -X 메서드를 사용한다
$ curl --http1.0 -X POST http://localhost:8080/greeting
```

### 스테이터스 코드
```
세 자리 숫자를 보고 서버가 어떻게 응답했는지 알 수 있다.

- 100번대: 처리가 계속됨을 나타낸다.
- 200번대: 성공했을 때의 응답. 
자주 사용되는 스테이터스 코드는 200 OK로 정상 종료를 나타낸다.
- 300번대: 서버에서 클라이언트로의 명령. 오류가 아니라 정상 처리의 범주.
리다이렉트나 캐시 이용을 지시한다.
- 400번대: 클라이언트가 보낸 요청에 오류가 있다.
- 500번대: 서버 내부에서 오류가 발생했다.
```

<br>
<hr>

## 리다이렉트
```
300번대 스테이터스의 일부는 서버가 브라우저에 대해 리다이렉트하도록 지시하는 스테이터스이다.
300 이외의 경우에는 Location 헤더를 사용해 리다이렉트할 곳을 서버에서 클라이언트로 전달한다.
```

|스테이터스 코드|메서드 변경|영구적/일시적|캐시|설명|
|---|---|---|---|---|
|301 Moved Permanently|O|영구적|한다|도메인 전송, 웹사이트 이전, HTTPS|
|302 Found|O|일시적|지시에 따름|일시적 관리, 모바일 기반 전송|
|303 See Other|허가|영구적|하지 않는다|로그인 후 페이지 전환|
|307 Temporary Redirect||일시적|지시에 따름||
|308 Moved Permanently||영구적|한다||

<br>
<hr>

## URL
```
URL (Uniform Resource Locator)

일반적으로 자주 보는 URL은 다음과 같은 형식이다.

https://www.oreilly.com/index.html
스키마://호스트명/경로



URL 사양에 포함되는 모든 요소가 들어간 예제는 다음과 같은 형식이다.
스키마://사용자:패스워드@호스트명:포트/경로#프래그먼트?쿼리
```

<br>
<hr>

## 바디
```
HTTP/0.9에서는 요청에 데이터를 포함할 수 없었다.

HTTP/1.0에서는 요청과 응답 양쪽에 헤더가 포함돼 바디와 헤더를 분리할 필요가 있다.
또한 요청에도 컨텐츠를 포함할 수 있게 돼 새로운 역할이 늘어났다.

헤더 끝에 빈 줄을 넣으며 그 이후에는 모두 바디가 된다.
```

### GET 요청 시의 바디
```
HTTP의 메서드 중에는 바디를 포함하는 것이 기대되지 않는 메서드가 있다 (GET, HEAD)

GET과 함께 바디를 보낼 수 있지만, 그렇게 하는것이 결코 유용하지 않다.
```























