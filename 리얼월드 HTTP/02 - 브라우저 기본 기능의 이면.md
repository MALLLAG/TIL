## 단순한 폼 전송 (x-www-form-urlencoded)
```
$ curl --http1.0 -d title="The Art of Community" -d author="Jono Bacon"
http://localhost:8080

curl 커맨드의 -d 옵션을 이용해 폼으로 전송할 데이터를 설정할 수 있다.
curl 커맨드는 -d 옵션이 지정되면 브라우저와 똑같이 헤더로 Content-Type:application/x-www-form-urlencoded 를 설정한다.

이때 바디는 키와 값이 '='로 연결되고, 각 항목이 &으로 연결된 문자열이다.
title=The Art of Community&author=Jono Bacon

단, 실제로는 이 커맨드가 생성하는 바디는 브라우저의 웹 폼에서 전송한 것과는 약간 차이가 있다.
-d 옵션으로 보낼 경우 지정된 문자열을 그대로 연결한다.
구분 문자인 &와 =이 있어도 그대로 연결해버리므로, 읽는 쪽에서 원래 데이터 세트로 복원할 수 없다.


브라우저는 RFC 1866에서 책정한 포맷에 따라 변환한다.
이 포맷에서는 알파벳, 수치, 별표, 하이픈, 마침표, 언더스코어의 여섯 종류 외에는 변환이 필요하다.

title=Head First & MySQL&author=Lynn Beighley, Michael Morrison
이 실제로는 다음과 같이 된다.
title=Head+First+PHP+%26+MySQL&author=Lynn+Beighley%2C+Michael+Morrison

이 방식에서는 이름과 값 안에 포함되는 =와 &은 각각 %3D와 %26으로 변환된다.
```

<br>
<hr>

## 폼을 이용한 파일 전송
```
HTML의 폼에서는 옵션으로 멀티파트 폼 형식이라는 인코딩 타입을 선택할 수 있다.

<form action="POST" enctype="multipart/form-data">
</form>

보통 HTTP 응답은 한 번에 한 파일씩 반환하므로, 빈 줄을 찾아 Content-Length로 지정된 바이트 수만큼 읽기만 하면
데이터를 통째로 가져올 수 있다. 
파일의 경계를 신경 쓸 필요가 없다.

하지만 멀티파트를 이용한다면 한 번의 요청으로 복수의 파일을 전송할 수 있으므로 받는 쪽에서 파일을 나눠야 한다.
```

<br>
<hr>

## 폼을 이용한 리다이렉트
```
300번대 스테이터스 코드를 사용한 리다이렉트는 몇가지 제한이 있다.
- URL에는 2천 자 이내라는 기준이 있어, GET의 쿼리로 보낼 수 있는 데이터 양에 한계가 있다.
- 데이터가 URL에 포함되므로, 전송하는 내용이 액세스 로그 등에 남을 우려가 있다.

이런 문제를 피하고자 이용되는 방법이 HTML의 폼을 이용한 리다이렉트이다.
```

<br>
<hr>

## 쿠키
```
웹사이트의 정보를 브라우저 쪽에 저장하는 작은 파일.

데이터베이스는 클라이언트가 데이터베이스 관리 시스템에 SQL을 발행해서 데이터를 저장하지만,
쿠키의 경우는 거꾸로 서버가 클라이언트에게 쿠키 저장을 지시한다.

쿠키는 HTTP 헤더를 기반으로 구현되었다

HTTP는 stateless를 기본으로 개발되었지만, 쿠키를 이용하면 stateful처럼 보이게 서비스를 제공할 수 있다.
```

### 쿠키의 잘못된 사용법
```
쿠키의 경우 몇 가지 제약 사항이 있다.

- 영속성 문제
비밀 모드나 브라우저의 보안 설정에 따라 세션이 끝나면 초기화되거나 쿠키를 보관하라는 서버의 지시를 무시하기 한다.
방문 기록 삭제나 개발자 도구 등으로 삭제되는 경우도 있다.

- 용량 문제
쿠키의 최대 크기는 4킬로바이트 사양으로 정해져 있어 더 보낼수는 없다.
쿠키는 헤더로서 항상 통신에 부가되므로 통신량이 늘어나고, 이로 인해 요청과 응답 속도에 영향을 미친다.

- 보안 문제
secure 속성을 부여하면 HTTPS 프로토콜로 암호화된 통신에서만 쿠키가 전송되지만, HTTP 통신에서는 쿠키가 평문으로 전송된다.
매 요청 시 쿠키가 송수신 되는데, 보이면 곤란한 데이터가 포함되면 노출될 위험이 있다.
암호화 된다고 해도 사용자가 자유롭게 접근해, 쿠키를 수정할 수 있는것도 문제이다
```

### 쿠키에 제약을 주다
```
- Expires, Max-Age
쿠키의 수명을 설정.

- Domain
클라이언트에서 쿠키를 전송할 대상 서버. 생략하면 쿠키를 발행한 서버가 된다.

- Path
클라이언트가 쿠키를 전송할 대상 서버의 경로. 생략하면 쿠키를 발행한 서버의 경로.

- Secure
https로 프로토콜을 사용한 보안 접속일때만 클라이언트에서 서버로 쿠키를 전송한다.

- HttpOnly
이 속성을 붙이면 자바스크립트 엔진으로부터 쿠키를 감출 수 있다.
크로스 사이트 스크립팅 등 악의적인 자바스크립트가 실행되는 보안 위험에 대한 방어가 된다.

- SameSite
이 속성은 RFC에는 존재하지 않는다.
크롬 브라우저 버전 51에서 도입한 속성으로, 같은 오리진의 도메인에 전송
```

<br>
<hr>

## 인증과 세션

### 쿠키를 사용한 세션 관리
```
최근 많이 사용되는 방식은 폼을 이용한 로그인과 쿠키를 이용한 세션 관리.

클라이언트는 폼으로 아이디와 비밀번호를 전송하고, 서버 측은 유저 아이디와 패스워드로 인증하고 문제가 없으면 세션 토큰을 발행한다.
서버는 세션 토큰을 관계형 DB나 키밸류형 DB에 저장.
토큰은 쿠키로 클라이언트에게 되돌아간다.
두번째 이후 접속에서는 쿠키를 재전송해서 로그인된 클라이언트임을 서버가 알 수 있다.

웹 서비스에 따라 CSRF 대책으로 랜덤 키를 보내는 경우도 있다.
```

<br>
<hr>

## 프록시
```
프록시는 HTTP 등의 통신을 중계한다.

때로는 중계뿐만 아니라 각종 부가 기능을 구현한 경우도 있다.
예를 들어 회사나 대학에서 구성원 중 누군가 접근한 컨텐츠는 다른 구성원도 접근할 가능성이 높다.
그럴때 캐시 기능이 있는 프록시를 조직의 네트워크 출입구에 설치하면, 컨텐츠를 저장한 웹 서버의 부담을 줄이고
사용자가 페이지를 빠르게 열람할 수 있다.

또한 프록시는 외부 공격으로부터 네트워크를 보호하는 방화벽 역할도 한다.

저속 통신 회선용으로 데이터를 압축해 속도를 높이는 필터나 컨텐츠 필터링에도 프록시가 사용된다.



프록시와 비슷한 게이트웨이가 있는데 차이점은 다음과 같다.

- 프록시
통신 내용을 이해한다. 필요에 따라 컨텐츠를 수정하거나 서버 대신 응답한다.

- 게이트웨이
통신 내용을 그대로 전송한다. 내용 수정도 불가.
```

<br>
<hr>

## 캐시
```
컨텐츠가 변경되지 않았을때 로컬에 저장된 파일을 재사용함으로써 다운로드 횟수를 줄이고 성능을 높여준다.

GET, HEAD 메서드 외에는 기본적으로 캐시되지 않는다.
```

<br>
<hr>

## Referer
```
사용자가 어느 경로로 웹사이트에 도달했는지 서버가 파악할 수 있도록 클라이언트가 서버에 보내는 헤더.

클라이언트가 http://www.example.com/link.html의 링크를 클릭해서 다른 사이트로 이동할 때 아래와 같은 형식을 전송
Referer: http://www.example.com/link.html

만약 북마크에서 선택하거나 주소창에서 키보드로 직접 입력했을 때는 Referer 태그를 전송하지 않거나 Referer:about:blank를 전송
```

<br>
<hr>

## 검색 엔진용 컨텐츠 접근 제어
```
검색 엔진이 정보를 수집하는 자동 순회 프로그램이 많이 운용되게 됐다.

이 크롤러의 접근을 제어하는 방법으로 주로 다음 두 가지 방법이 사용된다.
- robots.txt
- 사이트맵


robots.txt는 서버 컨텐츠 제공자가 크롤러에 접근 허가 여부를 전하기 위한 프로토콜.
robots.txt는 다음과 같은 형식으로 읽기를 금지할 크롤러의 이름과 장소를 지정.

User-agent: *
Disallow: /cgi-bin/
Disallow: /tmp/


사이트맵은 웹사이트에 포함된 페이지 목록과 메타데이터를 제공하는 xml 파일.
robots.txt가 블랙리스트처럼 사용된다면, 사이트맵은 화이트리스트처럼 사용.
```






















