## int 상수 대신 열거 타입을 사용하라

> 열거 타입은 일정 개수의 상수 값을 정의한 다음, 그 외의 값은 허용하지 않는 타입이다. <br>

```java
// 정수 열거 패턴
// 타입 안전을 보장할 수 없으며 표현력도 좋지 않다.
public static final int APPLE_FUJI = 0;
public static final int APPLE_PIPPIN = 1;
public static final int APPLE_GRANNY_SMITH = 2;
```

<br>

> 다음은 가장 단순한 열거 타입이다. <br>
> 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개한다. <br>
> 클라이언트가 인스턴스를 직접 생성하거나 확장 할 수 없으니 열거 타입 선언으로 만들어진 인스턴스들은 딱 하나씩만 존재한다. <br>
> 열거 타입은 컴파일타임 타입 안정성을 제공한다. <br>
> Apple 타입을 매개변수로 받는 메서드를 선언했다면, 건네받은 참조는 Apple 세가지 중 하나임이 확실하다. <br>
> 또한 각자의 이름 공간이 있어 이름이 같은 상수도 평화롭게 공존한다. <br>
> 열거 타입에 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일하지 않아도 된다

```java
public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }
public enum Orange { NAVEL, TEMPLE, BLOOD }
```

<br>

> 다음과 같이 열거 타입에 메서드나 필드를 추가해 사용할 수도 있다. <br>
> 각 상수를 특정 데이터와 연결짓거나 상수마다 다르게 동작하게 할 때 필요하다.
> 드물게는 하나의 메서드가 상수별로 다르게 동작해야 할 때도 있다. <br>
> 이럴때는 switch문 대신 상수별 메서드 구현을 사용하자.

```java
public enum Planet { 
    MERCURY(3.302e+23, 2.439e6), 
    VENUS (4.869e+24, 6.052e6), 
    EARTH (5.975e+24, 6.378e6), 
    MARS (6.419e+23, 3.393e6), 
    JUPITER(1.899e+27, 7.149e7), 
    SATURN (5.685e+26, 6.027e7), 
    URANUS (8.683e+25, 2.556e7), 
    NEPTUNE(1.024e+26, 2.477e7);
    
    private final double mass; // 질량
    private final double radius; // 반지름
    private final double surfaceGravity; // 표면중력
    
    // 중력상수(단위: nT3 / kg sA2)
    private static final double G = 6.67300E-11;
    
    // 생성자
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
        surfaceGravity = G * mass / (radius * radius);
    }
    
    public double massO { 
        return mass; 
    }
    
    public double radius() { 
        return radius; 
    }
    
    public double surfaceGravity() { 
        return surfaceGravity;
    }
    
    public double surfaceweight(double mass) { 
        return mass * surfaceGravity; // F = ma
    }
}
```

<br>
<hr>

## ordinal 메서드 대신 인스턴스 필드를 사용하라

> 대부분 열거 타입 상수는 하나의 정숫값에 대응된다. <br>
> 그리고 모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal이라는 메서드를 제공한다.
> 다음은 ordinal을 사용한 예이다. <br>
> 동작은 하지만 유지보수하기 끔찍한 코드이다. <br>
> 상수 선언 순서를 바꾸는 순간 numberOfMusicians가 오동작하고 이미 사용중인 정수와 값이 같은 상수는 추가할 수 없다. <br>
> 또한 값을 중간에 비워둘수도 없다.

```java
public enum Ensemble {
    SOLO, DUET, TRIO, QUARTET, QUINTET,
    SEXTET, SEPTET, OCTET, NONET, DECTET;
    
    public int numberOfMusicians() { return ordinal() + 1; } }
```

<br>

> 다음과 같이 인스턴스 필드에 저장하여, 위의 단점을 해결한다

```java
public enum Ensemble {
    SOLO(1), DUET(2), TRI0(3), QUARTET(4), QUINTET(5),
    SEXTET(6), SEPTET(7), 0CTET(8), D0UBLE_QUARTET(8),
    NONET(9), DECTET(10) , TRIPLE_QUARTET(12);
    
    private final int numberOfMusicians;
    Ensemble(int size) { this.numberOfMusicians = size; }
    public int numberOfMusicians { return numberOfMusicians; }

```

<br>
<hr>















