# 로 타입은 사용하지 마라

> 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.

```java
// 다음과 같이 사용 X
// 이 코드를 사용하면 실수로 Stamp 대신 Coin을 넣어도 아무 오류 없이 컴파일되고 실행된다
private final Collection stamps = ...;


// 다음과 같이 사용해서 타입 안정성 확보
private final Collection<Stamp> stamps = ...;
```

<br>

> 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표(?)를 사용하자
> 와일드카드 타입은 안전하고, 로 타입은 안전하지 않다.

```java
// 타입 안전하며 유용
static int numElementsInCommon(Set<?> si, Set<?> s2) { ... }
```

<br>

> 예외로 런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.
> 그리고 로 타입이든 비한정적 와일드카드 타입이든 instanceof는 똑같이 동작한다.

```java
if (o instanceof Set) {
    Set<?> s = (Set<?>) o;
    ...
    ...
    ...
}

```


<br>
<hr>


# 배열보다는 리스트를 사용하라

> 배열은 공변이다. 
> Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다
> 반면 제네릭은 불공변이다.
> 서로 다른 타입 Type1과 Type2가 있을 때, List<Type1>은 List<Type2>의 하위 타입도 아니고 상위 타입도 아니다

```java
// 런타임에 실패하는 코드
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다."; // ArrayStoreException


// 컴파일에 실패하는 코드
List<Object> ol = new ArrayList<Long>(); // 호환되지 않는 타입이다.
ol.add("타입이 달라 넣을 수 없다.");
```

<br>
  
> 배열은 실체화된다.
> 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다




























