# 클래스와 멤버의 접근 권한을 최소화하라

> 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다.
> 정보 은닉의 장점은 다음과 같다.

- 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문.
- 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.
- 성능 최적화에 도움을 준다. 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음, 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문이다.
- 소프트웨어 재사용성을 높인다.
- 큰 시스템을 제작하는 난이도를 낮춰준다. 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문.

<br>
<br>

> public 클래스의 인스턴스 필드는 public이 아니어야 한다.
- 필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다.
- 필드가 수정될 때 다른 작업을 할 수 없게 되므로 public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.

<br>
<br>

> 클래스에서 pubHc static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.
```java
// 이런 필드나 접근자를 제공한다면 클라이언트에서 그 배열의 내용을 수정할수 있게 된다.
public static final Thing[] VALUES = { ... };
```

- 첫 번째 해결 방법
```java
// public 배열을 private으로 만들고 public 불변 리스트를 추가
private static final Thing[] PRIVATE_VALUES = { ... }; 
public static final List<Thing> VALUES =
  Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

<br>

- 두 번째 해결 방법
```java
// 배열을 private으로 만들고 그 복사본을 반환하는 public 메서드를 추가
private static final Thing[] PRIVATE_VALUES = { ... }; 
public static final Thing[] values() {
  return PRIVATE_VALUES.cloneO; 
}
```


<br>
<hr>


# public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

> 이런 클래스는 데이터 필드에 직접 접근할 수 있으니 캡슐화의 이점이 없다.
```java
class Point {
  public double x;
  public double y; 
}
```

<br>
<br>

> 필드들을 모두 private으로 바꾸고 getter를 추가한다
```java
class Point {
  private double x; 
  private double y;
  
  public Point(double x, double y) { 
    this.x = x;
    this.y = y;
  }
  
  public double getX() { return x; } 
  public double getY() { return y; }
```


<br>
<hr>


# 변경 가능성을 최소화하라

> 불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스이다.
> 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.
> 클래스를 불변으로 만들려면 다음 규칙을 따르면 된다.

- 객체의 상태를 변경하는 메서드를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다.
- 모든 필드를 final로 선언한다.
- 모든 필드를 private으로 선언한다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.


<br>
<hr>


# 상속보다는 컴포지션을 사용하라

> 일반적인 구체 클래스를 패키지 경계를 넘어, 다른 패키지의 구체 클래스를 상속하는 일은 위험하다
> 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.
> 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
> 상위 클래스는 내부 구현이 달라질 수 있으며, 그 여파로 코드 한 줄 건드리지 않은 하위 클래스가 오동작할 수 있다.

<br>

- 이상의 문제를 피하려면 ???

> 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자.
> 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다.
> 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며
> 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향받지 않는다.


<br>
<hr>


# 상속을 고려해 설계하고, 그러지 않았다면 상속을 












