## HTTP 2
```
데이터 표현이 HTTP 1.1과 달라졌다

1. 스트림을 사용해 바이너리 데이터를 다중으로 송수신하는 구조로 변경했다.
2. 스트림 내 우선 순위 설정과 서버 사이드에서 데이터 통신을 하는 서버 사이드 푸시를 구현했다.
3. 헤더가 압축되게 되었다.

HTTP 2의 목적은 통신 고속화뿐이다.

TCP 소켓 수준에서 보면 다음과 같은 개선이 이루어졌다.
```

|기능|효과|
|---|---|
|캐시(max-age)|통신 자체를 취소|
|캐시(ETag, Date)|변경이 없으면 바디 전송을 취소|
|Keep-Alive|액세스마다 연결에 걸리는 시간 (1.5TTL)을 줄임|
|압축|응답 바디 크기 절감|
|청크|응답 전송 시작을 빠르게 함|
|파이프라이닝|통신 다중화|


### 스트림을 사용한 통신 고속화
```
HTTP 2에서의 가장 큰 변화는 텍스트 기반 프로토콜에서 바이너리 기반 프로토콜로 변화했다는 점이다.

HTTP 1.1까지는 하나의 요청이 TCP 소켓을 독점했기 때문에, 하나의 오리지널 서버에 대해 2~6개의 TCP 접속을 해서 병렬화 했다.
HTTP 2에서는 하나의 TCP 접속 안에 스트림이라는 가상의 TCP 소켓을 만들어 통신한다.
스트림은 프레임에 따른 플래그로 간단히 만들고 닫을 수 있는 규칙으로 되어 있고, 일반 TCP 소켓과 같은 핸드셰이크는 필요 없다.
그래서 ID 값과 TCP 통신 용량이 허용하는 한, 몇 만번의 접속이라도 병렬화 할 수 있다.
```

### HTTP 2의 애플리케이션 계층
```
HTTP 1.0은 단순히 데이터를 운반하는 상자였다.
그 뒤로 Keep-Alive, 파이프라이닝 등 하위 계층의 통신 처리에 영향을 주는 기능도 포함하기 시작했지만
메서드와 경로, 헤더, 바디, 스테이터스 코드라는 네가지 기본 요소가 존재한다는 것은 변함이 없다.

HTTP 1.1은 텍스트 프로토콜이였다.
헤더의 종단을 찾으려면 빈 줄을 찾을 때까지 1바이트씩 미리 읽어 발견할 필요가 있다.
오류 처리도 있고 서버로서는 해석까지 포함해 순차적으로 처리할 수 밖에 없으므로 고급 병렬 처리는 어렵다.

HTTP 2는 바이너리화 되어, 처음에 프레임 크기가 들어간다.
TCP 소켓 레이어에서는 데이터를 프레임 단위로 쉽게 분리할 수 있으므로, 수신측 TCP 소켓의 버퍼를 빠르게 비울 수 있고
통신 다음 상대에게 다음 데이터를 고속으로 요청할 수 있다.
```

### 플로 컨트롤
```
HTTP 2는 인터넷 4계층 모델 중 애플리케이션 층에 해당하지만, 트랜스포트 층에 가까운 것을 내부에 가지고 있다.

플로 컨트롤은 스트림을 효율적으로 흐르게 하려고 이용되는 통신량 제어 처리이다.
통신 속도가 지나치게 차이 나는 기기의 조합으로 통신할 때 빠른 쪽이 느린 쪽에 대량으로 패킷을 보내버려
처리할 수 없게 되는 사태를 방지하는 게 목적이다.

송신하는 쪽은 상대방의 최대 버퍼 크기만큼 데이터를 보낸다.
수신하는 쪽은 전송된 패킷을 처리하고 버퍼에 여유가 생기면, WINDOW_UPDATE 프레임을 이용해 새로 생긴 여유 버퍼 크기를 송신하는 쪽에 반환한다.
송신하는 쪽에서 이 통지를 받으면, 새로 생신 여유 버퍼를 채울 만큼 이어지는 데이터를 보낸다.
```

### 서버 푸시
```
서버 푸시를 이용해 우선순위가 높은 콘텐츠를 클라이언트가 요구하기 전에 전송할 수 있게 되었다.
단 웹소켓처럼 양방향 통신을 실현하는 기술과 달리, CSS와 자바스크립트, 이미지 등 웹 페이지를 구성하는 파일을 다운로드하는 용도로 이용된다.
푸시된 컨텐츠는 사전에 캐시에 들어가고, 클라이언트가 그 파일을 요청하면 곧바로 다운로드할 수 있는 것 처럼 보인다.
```

### HPACK을 이용한 헤더 압축
```
헤더는 HPACK이라는 방식으로 압축된다.

HTTP 헤더에서는 정해진 이름이나 결과가 자주 출현하므로, 이를 외부 사전에 넣어두면 압축 후 크기가 작아진다.
HTTP 2에서는 정적 테이블이라는 이름으로 사전에 빈번하게 출현하는 헤더 이름과 헤더 값을 테이블로 가지고 있다.

추가로 같은 커넥션에서 등장한 HTTP 헤더는 인덱스화되어 동적 테이블에 저장된다.
다시 등장할때는 인덱스 값만으로 표현할 수 있으므로 작은 크기로 송신이 가능하다.
```

<br>
<hr>

## Fetch API
```
Fetch API는 XMLHttpRequest와 마찬가지로 서버 액세스를 하는 함수이다.
자바스크립트에서 활용되며 다음과 같은 특징이 있다.

- XMLHttpRequest보다 서버 오리진 밖으로의 액세스 등 CORS 제어가 쉬워진다.
- 자바스크립트의 모던한 비동기 처리 작성 기법인 프로미스(Promise)를 따른다.
- 캐시를 제어할 수 있다.
- 리디렉트를 제어할 수 있다.
- 리퍼러 정책을 설정할 수 있다.
- Service Worker 내에서 이용할 수 있다.

추가로, 브라우저에서 ssh로 외부 서버에 연결되거나 Git 프로토콜을 보내거나 웹 서버를 개발하는 등의 용도로는 사용할 수 없다.
```

### Fetch API의 기본
- Fetch API의 사용 예

```javascript
fetch("news.json", {
    method: 'GET',
    mode: 'cors',
    credentials: 'include',
    cache: 'default'
    headers: {
        'Content-Type': 'application/json'
    }
  }).then((response => {
      return response.json();
  }).then((json => {
      console.log(json);
  });
```

```
기본 요소는 다음 네 가지이다.
1. XMLHttpRequest처럼 오브젝트를 만드는게 아니라 fetch() 함수를 호출
2. fetch() 함수의 두번째 인수는 옵션 오브젝트 (생략 가능)
3. .then() 함수에 서버 응답이 돌아온 후에 호출되는 콜백을 넘겨준다 (프로미스)
4. .then()에 넘겨주는 콜백이 다시 시간이 걸리는 처리를 하고, 그 처리가 프로미스를 반환할때는 .then()을 연결한다


Fetch API의 첫 번째 .then() 절은 응답의 헤더 부근까지 읽기를 마친 시점에서 호출된다.
또한 다양한 자료형을 지원해서, 첫 번째 .then() 절 안에서 바디를 어떤 형식으로 가져올지 메서드 호출로 결정한다.
그 뒤 처리는 서버에서의 읽기를 동반하므로, 다시 .then() 절을 호출해 다운로드가 끝나기를 기다린다.
```

|대응|메서드 목록|
|---|---|
|CORS 안전|GET, HEAD, POST|
|금지 메서드|CONNECT, TRACE, TRACK|


<br>

### Fetch API만 할 수 있는 것
- 캐시 제어
Fetch API의 특징으로서 자주 소개되는 것이 캐시이다. 캐시는 세밀하게 제어할 수 있다.

|설정값|기본|설명|
|---|---|---|
|Default|o|표준적인 브라우저 동작을 따른다.|
|no-store||캐시가 없는 것으로 해서 요청한다. 결과도 캐시하지 않는다.|
|Reload||브라우저 새로고침과 같은 캐시가 없는것으로 해서 요청한다. ETag 등은 보내지 않는다. 캐시 가능하면 결과를 캐시한다.|
|no-cache||기한 내의 캐시가 있어도 HTTP 요청을 보낸다. 로컬 캐시의 ETag 등도 보내고, 서버가 304를 반환하면 캐시한 컨텐츠를 사용한다.|
|force-cache||기한이 지난 캐시라도 있으면 이용한다. 없으면 HTTP 요청을 보낸다.|
|only-if-cached||기한이 지난 캐시라도 있으면 사용한다. 없으면 오류가 발생한다.|

<br>

- 리디렉트 제어

|설정 값|기본|설명|
|---|---|---|
|follow|o|리디렉트를 따라간다 (최대 20 리디렉트까지)|
|manual||리디렉트를 따라가지 않고 리디렉트가 있다는 것만 전달한다|
|error||네트워크 오류로 한다|

<br>

- Service Worker 대응
```
현재 Service Worker 내에서 외부 서비스로 접속할 때는 Fetch API만 사용할 수 있는 사양으로 되어 있다.

Service Worker는 애플리케이션의 생애 주기와 통신 내용을 제어할 수 있는 것으로 지원하는 
웹 서비스는 오프라인으로 동작할 수 있게 되거나 통지를 다룰 수 있게 된다.

Service Worker는 웹 서비스의 프론트엔드 자바스크립트와 서버 사이에서 동작하는 중간 레이어이다.
```

<br>
<hr>

## server-sent events





















